import noble from '@abandonware/noble';

import {canonicalize_bluetooth_address, canonicalize_bluetooth_uuid, canonicalize_hex_string, get_timestamp, shorten_bluetooth_uuid, time_limit_promise} from './utils.mjs';

const ensure_noble_state_is = (desired_noble_state) =>
	(new Promise((resolve, reject) => {
		const check_noble_state = (noble_state) => {
			if (noble_state.toLowerCase() === desired_noble_state.toLowerCase()) {
				noble.off('stateChange', check_noble_state);
				resolve();
			}
		};
		noble.on('stateChange', check_noble_state);
	}))

const ensure_noble_is_ready = (timeout_millis=5000) =>
	time_limit_promise(ensure_noble_state_is('poweredOn'), timeout_millis, `noble did not change to "poweredOn" state within ${timeout_millis} milliseconds`)

const externalize_buffer = (buffer) =>
	((buffer instanceof Buffer)
		? {
			hex: canonicalize_hex_string(buffer.toString('hex')),
			array: [...buffer],
		}
		: null
	)

const externalize_bluetooth_uuid = (bluetooth_uuid) =>
	({
		long: canonicalize_bluetooth_uuid(bluetooth_uuid),
		short: shorten_bluetooth_uuid(bluetooth_uuid),
	})

const externalize_service_data = ({uuid, data}) =>
	({
		uuid: externalize_bluetooth_uuid(uuid),
		data: externalize_buffer(data),
	})

const scan_for_ble_advertisements = async (callback, interval=0) => {
	await ensure_noble_is_ready();
	await noble.startScanningAsync([], true);
	const last_timestamps = {};
	noble.on('discover', (noble_peripheral) => {
		const timestamp = get_timestamp();
		const canonical_address = canonicalize_bluetooth_address(noble_peripheral.address);
		if ((! last_timestamps.hasOwnProperty(canonical_address)) || (timestamp >= (last_timestamps[canonical_address] + (interval * 1000)))) {
			last_timestamps[canonical_address] = timestamp;
			callback({
				address: {
					long: canonical_address,
					short: canonicalize_hex_string(canonical_address),
				},
				address_type: noble_peripheral.addressType,
				connectable: noble_peripheral.connectable,
				name: noble_peripheral.advertisement.localName,
				tx_power_level: noble_peripheral.advertisement.txPowerLevel,
				service_uuids: noble_peripheral.advertisement.serviceUuids.map(externalize_bluetooth_uuid),
				solicitation_service_uuids: noble_peripheral.advertisement.solicitationServiceUuids.map(externalize_bluetooth_uuid),
				manufacturer_data: externalize_buffer(noble_peripheral.advertisement.manufacturerData),
				service_datas: noble_peripheral.advertisement.serviceData.map(externalize_service_data),
				rssi: noble_peripheral.rssi,
				timestamp: timestamp,
			});
		}
	});
}

export {scan_for_ble_advertisements};
